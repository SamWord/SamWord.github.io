---
layout: post
title: "HW14: Testing Reflections"
date: 2017-09-28
author: Sam Word
---

<p>It made me smile that Boris Beizer noted that nobody likes testing in the first few sentences of the <a target="blank" href="http://stono.cs.cofc.edu/~bowring/classes/csci%20362/docs/software.testing.introduction.pdf">Introduction in <em>Software Testing Techniques</em></a>. I personally dislike testing, despite knowing its necessity. In The Mythical Man Month, Brooks states that we love to program because we love making things, we love making useful things, we like solving complex problems, etc. Testing is none of those things. They may be useful, but they’re not something that people often interact with, so they’re not useful in a way that brings us much pleasure. With anything else I don’t enjoy doing, it helps to have motivation to do it, and Beizer offers a compelling argument on why testing is important.</p>
<p>Something I found really interesting about this introduction was the benefits and pitfalls of being a tester with knowledge of the system design. Testers with no knowledge of the software's design and intended use are more likely to break it by creating unusual, unintended test cases, which could be useful or unnecessary. The more a tester knows about the software’s design, the more efficiently you could test the software, but the tester may not think about odd use cases that would reveal a bug in the code. Beizer suggests that there should be a balance between the unintelligent testing mentality and the software designer mentality, and the separation between those two may differ depending on the project. This is something I personally need to keep in mind at my internship. My development team consists of only eight developers and one lead architect, and we are responsible for writing all of our unit tests and some systems tests. In my team, each developer is part software designer who implements a solution to a given problem, and part tester who is responsible for testing the solutions we provide.</p>
<p>Ultimately, we test to create low-risk software. Ideally, we implement our software in a way that is easy to test, resulting in less effort dedicated to writing tests and code with fewer bugs. That’s great, and something we should strive for, but the most frustrating thing Beizer points out about testing is that it’s impossible to prove that a system is bug-free. It’s always nice to see that all of my automated tests are passing, but it’s upsetting to think that no matter how much I test, I can never prove that my system is bug-free. To me, this makes testing even less satisfying. You can only try to determine how much testing is “enough.”
</p>
